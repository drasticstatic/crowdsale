// ========== APP.JS ==========

/* The main React component for our DApp to handle:
    Connecting to the Ethereum blockchain
    Loading smart contract data
    Displaying the user interface
    Managing the token purchase process */

import { useEffect, useState, useRef } from 'react'; // React hooks for state and lifecycle management
import { Container } from 'react-bootstrap';
import { ethers } from 'ethers'

// COMPONENTS: - the UI building blocks of our application
import Navigation from './Navigation'; // Navigation bar component
import Buy from './Buy'; // Component for buying tokens
import Progress from './Progress'; // Progress bar showing token sale status
import Info from './Info'; // Component showing account information
import Loading from './Loading'; // Loading spinner component

// Artifacts - These are the compiled smart contract files
  // They contain the ABI (Application Binary Interface) which tells our app how to interact with the contracts
import CROWDSALE_ABI from '../abis/Crowdsale.json' // Crowdsale contract interface
import TOKEN_ABI from '../abis/Token.json' // Token contract interface
/* Be sure to update (copy) the latest ABI artifacts: 'token.json' and 'crowdsale.json' from build directory (after compiling)<--if contracts are updated
    And paste into the 'src/abis' directory
      ABIs are JSON files generated by the Solidity compiler when we compile our smart contracts
      They contain the contract's functions, events, and types
      & are used by the ethers.js library to create contract instances that we can use to interact with the blockchain*/

// Config - Contains network-specific addresses for our contracts
import config from '../config.json';

function App() {
  // ===== STATE VARIABLES: =====
    // These variables store data that can change and cause the UI to update

  const configRef = useRef(config)// Create a ref for the config to avoid ESLint warnings
  /* Updated each 'config' below with 'configRef.current'
      Using useRef to store the config object so it doesn't change on every render
      This allows us to access the config without causing unnecessary re-renders
      This is useful when the config object is large or complex, as it avoids performance issues
      This is a workaround to avoid ESLint warnings about using config in the dependency array
      This is necessary because the config object is used in the loadBlockchainData function*/
  const tokenAbiRef = useRef(TOKEN_ABI)// Create a ref for the token ABI to avoid ESLint warnings
    // Updated 'TOKEN_ABI' below with 'tokenAbiRef.current' since "useRef" is used to store the token ABI so it doesn't change on every render
  const crowdsaleAbiRef = useRef(CROWDSALE_ABI)// Create a ref for the crowdsale ABI to avoid ESLint warnings
    // Similarly updated 'CROWDSALE_ABI' below with 'crowdsaleAbiRef.current'
  const ethersRef = useRef(ethers)// Create a ref for the ethers library to avoid ESLint warnings

  // Create a ref for window.ethereum
  const ethereumRef = useRef();
  // Update the ref when the component mounts
  useEffect(() => {
    ethereumRef.current = window.ethereum;
  }, []);

  /* Blockchain connection states
      These states hold the connection to the Ethereum network and the smart contracts
      They are used to interact with the blockchain and fetch data
      They are initialized to null (default) and will be set once the connection is established/the provider is instantiated*/
  const [provider, setProvider] = useState(null)          // Connection to Ethereum network
  const [crowdsale, setCrowdsale] = useState(null)        // Crowdsale contract instance

  // User account states
  const [account, setAccount] = useState("")              // User's Ethereum address
    /* ↑ Changed to empty string vs 'null' for better handling in the UI
        - 'account' is used to display the user's address and balance
        - 'setAccount' is used to update the account state when the user connects their wallet*/
  const [accountBalance, setAccountBalance] = useState(0) // User's token balance

  // Token sale states
  const [price, setPrice] = useState(0)                 // Price per token in ETH
  const [maxTokens, setMaxTokens] = useState(0)         // Total tokens available for sale
  const [tokensSold, setTokensSold] = useState(0)       // Number of tokens already sold
  
  // UI state
  const [isLoading, setIsLoading] = useState(true)      // Controls showing loading spinner
    /* ↑ 'true' is (default value) to show the loading spinner initially
      This state variable controls whether the loading spinner is displayed or not
      It is set to false once the blockchain data is loaded successfully or if an error occurs
      This is used to manage the loading state of the application*/

// ===== BLOCKCHAIN CONNECTION FUNCTION =====
  // This function connects to the blockchain and loads all necessary data
  const loadBlockchainData = async () => {
    try{
      // Check if MetaMask is installed
      if (typeof ethereumRef.current === 'undefined') {
        alert('Please install MetaMask to use this DApp')
        setIsLoading(false)
        return
      }
      // Request account access *FIRST* before creating the provider
        // This is necessary to ensure the user has granted permission to access their accounts
      await ethereumRef.current.request({ 
        method: 'eth_requestAccounts' 
      })

      // Initialize provider *AFTER* requesting accounts!
          // ↓ Instantiate Provider - Connect to Ethereum via MetaMask or other web3 provider
      const provider = new ethersRef.current.providers.Web3Provider(ethereumRef.current) // Creates a new provider instance
      // ↑ 'window.ethereum' (now ethereumRef.current) is injected by MetaMask allowing us to interact with the user's wallet and Ethereum network
      setProvider(provider)
      // ↑ Set the provider in the state so we can use it later
        console.log(provider) // Log the provider to the console for debugging
        // ↑ Check if the user has MetaMask installed and connected
        //console.log (`provider: ${provider}`)
        console.log(window.ethereum)// Log the injected web3 provider to the console for debugging
        //console.log (`window.ethereum: ${window.ethereum}`)
      
      // Check if MetaMask is connected
      async function checkMetaMaskConnection() {
        const accounts = await ethereumRef.current.request({ method: 'eth_accounts' });
        if (accounts.length === 0) {
          alert('Please connect to MetaMask');
          return;
        }
      }
      // Ensure this function is awaited
      await checkMetaMaskConnection();

      // Fetch the current network/chain ID to use the correct contract addresses
      const network = await provider.getNetwork()// Added 'const network' variable to fetch the network details
      const chainId = network.chainId
      console.log (`chainId: ${chainId}`) // Log the chain ID to the console for debugging

      // Use the appropriate config key based on chainId
      let configKey = chainId.toString(); // Added configKey variable due to using 'localDevelopmentNetwork' in config.json
      if (chainId === 31337 && configRef.current.localDevelopmentNetwork) {
        configKey = "localDevelopmentNetwork";
      }

      // Check if the config exists for this network
      if (!configRef.current[configKey]) {
        console.error(`Network configuration not found for chain ID ${chainId}`);
        alert(`Unsupported network. Please connect to a supported network.`);
        setIsLoading(false);
        return;
      }

        // Check if MetaMask is connected to the correct network
        const ethereumChainId = await ethereumRef.current.request({ method: 'eth_chainId' });
        const decimalChainId = parseInt(ethereumChainId, 16).toString();
        // Check again if this network exists in your config
        if (!configRef.current[decimalChainId]) {
        console.log(`Network ${decimalChainId} not found in config. Using 'localDevelopmentNetwork'.`);
        }
        // Check again if connected to correct network
        if (chainId !== parseInt(decimalChainId)) {
          alert('Please connect to the correct network');
          return;
        }
        // Log the available networks in your config:
        console.log("Available networks in config:", Object.keys(configRef.current));
      await checkMetaMaskConnection();

      // Check if addresses are placeholders and use hardcoded values for local development
      let tokenAddress = configRef.current[configKey].token.address;
      let crowdsaleAddress = configRef.current[configKey].crowdsale.address;
      // If addresses are placeholders, use hardcoded values for local development:
      if (tokenAddress === "$TOKEN_ADDRESS" || tokenAddress.includes("$")) {
        console.log("Using hardcoded token address for local development");
        tokenAddress = "0x5FbDB2315678afecb367f032d93F642f64180aa3"; // Common Hardhat first deployment address
      }
      if (crowdsaleAddress === "$CROWDSALE_ADDRESS" || crowdsaleAddress.includes("$")) {
        console.log("Using hardcoded crowdsale address for local development");
        crowdsaleAddress = "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512"; // Common Hardhat second deployment address
      }

      // Inititate contracts - Create JavaScript objects that represent our smart contracts
          // swapped 'chainId' for 'configKey' and now not needed in these constructors:
      const token = new ethersRef.current.Contract(
        tokenAddress,             // Address of token contract on this network (was token.address)
        tokenAbiRef.current,      // ABI (interface) of the token contract
        provider                  // Connection to Ethereum
      )
      
      const crowdsale = new ethersRef.current.Contract(
        crowdsaleAddress,         // Address of crowdsale contract (was crowdsale.address)
        crowdsaleAbiRef.current,  // ABI (interface) of the crowdsale contract
        provider                  // Connection to Ethereum
      )
      setCrowdsale(crowdsale)

      // Request/fetch access to user's MetaMask account
      const accounts = await ethereumRef.current.request({ method: 'eth_requestAccounts' });
      const account = ethersRef.current.utils.getAddress(accounts[0]) // Get the first account and format it
      setAccount(account) // Set the account in the state so we can use it later
      console.log (`account: ${account}`) // Log the user's account address to the console for debugging


      // Get the user's token account balance
      const accountBalance = ethersRef.current.utils.formatUnits(await token.balanceOf(account), 18)
      setAccountBalance(accountBalance)

      // Get token price from the crowdsale contract
      const price = ethersRef.current.utils.formatUnits(await crowdsale.price(), 18)
      setPrice(price)

      // Get maximum tokens available for sale
      const maxTokens = ethersRef.current.utils.formatUnits(await crowdsale.maxTokens(), 18)
      setMaxTokens(maxTokens)

      // Get number of tokens already sold
      const tokensSold = ethersRef.current.utils.formatUnits(await crowdsale.tokensSold(), 18)
      setTokensSold(tokensSold)
      console.log(`Blockchain data loaded successfully:
        Account: ${account}
        Balance: ${accountBalance} tokens
        Price: ${price} ETH
        Max Tokens: ${maxTokens}
        Tokens Sold: ${tokensSold}`);

      setIsLoading(false)// Data loading complete, hide the loading spinner

      // Try and catch - to check if MetaMask is connected to the correct network:
    } catch (error) {
      console.error("An error occurred while loading blockchain data:", error);
      alert("Failed to load blockchain data. Please check your connection and try again.");
    } finally { // Ensure loading state is updated regardless of success or failure
      setIsLoading(false);
    }
  }

// ===== EFFECT HOOK =====
  // This runs when the component mounts or when 'isLoading' changes
    // It's like an automatic trigger for the 'loadBlockchainData' function
  useEffect(() => {
    if (isLoading) {
      loadBlockchainData();
    }
  }, [isLoading]) // The dependency array - effect runs when these values change

  // ===== USER INTERFACE / RENDERING THE COMPONENT =====
    /* (What gets displayed on the webpage)
      The return statement defines what the UI looks like
      It uses JSX to describe the structure of the UI*/
  return (
    <Container>
      {/* 'Navigation' component - bar always shows at the top */}
      <Navigation />

      <h1 className='my-4 text-center'>Introducing DApp Token!</h1>
      {/* ↑ h1 header with margin for spacing - centered title */}

      {/* 'Loading' component - conditional rendering - show loading spinner or main content */}
      {isLoading ? (
        <Loading />
      ) : (
        <>
          {/* Token price display */}
          <p className='text-center'><strong>Current Price:</strong> {price} ETH</p>
          
          {/* 'Buy component' - allows users to purchase tokens */}
          <Buy 
            provider={provider} 
            price={price} 
            crowdsale={crowdsale} 
            setIsLoading={setIsLoading} 
          />
          
          {/* 'Progress' component - bar showing token sale status */}
          <Progress maxTokens={maxTokens} tokensSold={tokensSold} />
        </>
      )}

      <hr /> {/* Separator line for visual clarity */}

      {/* 'Info' component - only show account info (address & balance) if connected to an account - && checks truthiness and if present, then render */}
      {account && (
        <Info account={account} accountBalance={accountBalance} />
      )}
    </Container>
  );
}

export default App;  // Makes this component available for import in other files

// ========== END OF APP.JS ==========
